// ðŸ‘€ ì„œë¬¸:
// í•œ ì§‘ì”©ë§Œ ê±´ë„ˆë›°ì–´ ìµœëŒ€ê°’ì„ êµ¬í•˜ëŠ” í™€ì§ ìµœëŒ€ê°’ë§Œ ë¹„êµí•˜ëŠ” ë°©ë²•ë„ ìƒê°í•´ë´¤ê³ ,
// í•œ ì§‘ì”©ë§Œ ê±´ë„ˆë›°ì—ˆì„ ë•Œ ìµœëŒ€ê°’ê³¼ ë‘ ì§‘ì”© ê±´ë„ˆë›°ì—ˆì„ ë•Œ ìµœëŒ€ê°’ì„ ë¹„êµí•˜ëŠ” ë°©ë²•ë„ ìƒê°í•´ë´¤ëŠ”ë°,
// "ì í™”ì‹"ì„ ì •ì˜í•˜ì§€ ì•Šê³  ì ‘ê·¼í•˜ë‹¤ë³´ë‹ˆ ë„ì €ížˆ ë°©ë²•ì´ ë– ì˜¤ë¥´ì§€ ì•Šì•˜ë‹¤.

// ðŸ”¥ ê²°êµ­ GPTë¡œ ê¹¨ë‹¬ì€ ì ‘ê·¼ë²• : ì í™”ì‹ ì •ì˜
// ì í™”ì‹ì„ ì •ì˜í•˜ê¸° ìœ„í•œ ì¤‘ìš”í•œ ê´€ì ì€ "ië²ˆì§¸ ê²°ê³¼ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìžˆëŠ” ê²ƒ, i-1ë²ˆì§¸ ê²°ê³¼ì™€ i-2ë²ˆì§¸ ê²°ê³¼ ë¿"ì´ë¼ëŠ” ê²ƒì´ë‹¤.
// ì¦‰, ië²ˆì§¸ ì§‘ì„ í„¸ì§€ ì•ŠëŠ”ë‹¤ë©´ i-1ë²ˆì§¸ ì§‘ê¹Œì§€ì˜ ìµœëŒ€ê°’ì´ ë˜ê³ ,
// ië²ˆì§¸ ì§‘ì„ í„¸ë©´ i-2ë²ˆì§¸ ì§‘ê¹Œì§€ì˜ ìµœëŒ€ê°’ + ië²ˆì§¸ ì§‘ì˜ ê¸ˆì•¡ì´ ëœë‹¤.
// ë”°ë¼ì„œ ì í™”ì‹ì€ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•  ìˆ˜ ìžˆë‹¤.

// â­ï¸ ì í™”ì‹:
// dp[i] = max(dp[i-1], dp[i-2] + nums[i])
// dp[i]ì€ ië²ˆì§¸ ì§‘ì„ í„¸ì—ˆë‹¤ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ië²ˆì§¸ ì§‘ê¹Œì§€ì˜ ìµœëŒ€ê°’ì„ ì˜ë¯¸í•œë‹¤.

class Solution {
    func rob(_ nums: [Int]) -> Int {
        let n = nums.count
        if n == 0 {
            return 0
        } else if n == 1 {
            return nums[0]
        }
        
        var prev1 = 0   // i-1 ì§‘ê¹Œì§€ ìµœëŒ€ë¡œ í›”ì¹  ìˆ˜ ìžˆëŠ” ê¸ˆì•¡, dp[i-1]
        var prev2 = 0   // i-2 ì§‘ê¹Œì§€ ìµœëŒ€ë¡œ í›”ì¹  ìˆ˜ ìžˆëŠ” ê¸ˆì•¡, dp[i-2]
        
        for num in nums {
            let temp = prev1
            prev1 = max(prev2 + num, prev1)
            prev2 = temp
        }
        
        return prev1
    }
}